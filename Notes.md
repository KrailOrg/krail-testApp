# Objectives for Automated Functional Testing

1. Remove the need for manually created Page Objects
1. Syntax for tests as natural as possible
1. Use the same script for running tests in Selenide, TestBench or Coded
1. Must work with any general Java / Kotlin test framework - Spek, JUnit etc



## Constraints

### Execution mode

enum Selenide, TestBench or Coded


### objectives 1 and 2

To satisfy objectives 1 and 2 together page objects will need to be generated.  A dynamically generated page object is entirely possible but would not lead to an easy syntax.
We would have to use something like 
``
view["fieldname"] captionShouldBe("X")
``
instead of

``
view.fieldname captionShouldBe("X")
``

- **Generating page objects** can be done through the ComponentIdGenerator, combined with the MasterSitemap.  This would give us a tree of Url-View-component-component and UI-component-component (components to whatever depth)


### objective 3

A structure of "Elements" mirroring the structure of Vaadin components (very similar to TestBench).  Each element type needs to know which execution mode the test script is running in, and select the element appropriately.

For this, Coded would need access to the current UI and View

Q: Do these elements need to be interfaces instantiated for each execution mode, or concrete classes which choose the correct selection method for the execution mode?

### objective 4

Probably the only impact of this is that it should be written in Kotlin


### Notes
Kotlin's dynamic type turns off type checking
Need a decent tree or maybe Graph implementation to hold the structure

## Solution

The element definitions are generated by the ComponentIdGenerator and combined with the MasterSitemap output to provide a Google Guava graph of Url-View-component-component and UI-component-component (components to whatever depth)  
The PageObject interface defines all the methods for retrieving element attributes.  Pluggable implementations are used for each execution mode
A PageObject combines a ViewObject and a UIObject 
The PageObjectGenerator takes a view definition and a UI definition and creates a page object class in Kotlin code


## Development
Phase 1 uses manually created page objects in place of a generator - this will help iron out bugs in the design

## ViewObject

We have to specify each property as initialised by function, lateinit,  mapped or using a property delegate.  The first would need the property name passing to it
The neatest for manual creation is probably lateinit, but mapped would also allow a syntax of:

```kotlin
view["password"].

```

### Initialise by function

```kotlin
class LoginViewObject{
    val password : textFieldElement("password")
}

```

### lateinit
```kotlin
class LoginViewObject {
    lateinit var password : TextFieldElement
}

```


### mapped
```kotlin
class LoginViewObject : HashMap<String,Any>(){
    val password : TextFieldElement by this
}

```


### delegated
```kotlin
class LoginViewObject : ViewElement {
    val password by TextField()
}
```


